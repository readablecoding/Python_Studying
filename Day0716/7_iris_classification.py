# -*- coding: utf-8 -*-
"""7_Iris_Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zYAEIU0KUjfBlIi5rtO6YfR0mDmsih9M
"""

#구글에서 제공하는 GPU를 이용해서 계산하기
!pip install tensorflow-gpu==2.2.0

import tensorflow as tf
tf.__version__

#관련 모듈을 전부 import
from keras.models import Sequential
from keras.layers import Dense
from keras.optimizers import Adam

from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns

iris = sns.load_dataset("iris")
iris

iris.info()

X = iris.iloc[:, 0:4].values # ndarray 2차원 (float64)
y = iris.iloc[:, 4].values # ndarray 1차원 (문자)

le = LabelEncoder()
y1 = le.fit_transform(y) # 0, 1, 2
Y = pd.get_dummies(y1).values # ndarray 2차원 one hot encoding이 완료된 데이터
Y

# 위에서 전처리가 끝난 X, Y를 훈련 / 검증 데이터로 나눈다

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size = 0.2, random_state = 1)
X_train.shape, X_test.shape, y_train.shape, y_test.shape

# 모델 생성

model = Sequential()

model.add(Dense(64, activation="relu", input_shape=(4, ) ))
model.add(Dense(64, activation="relu"))
model.add(Dense(3, activation="softmax")) # 마지막으로 3개 중 하나를 고르도록 함

model.summary()

model.compile(optimizer='Adam', loss = 'categorical_crossentropy', metrics=['accuracy']) # SGD, MSE(선형회귀에 사용), categorical_crossentropy(3개 중 하나, 2개중 하나 고를 때)

hist = model.fit(X_train, y_train, epochs=100, validation_data=(X_test, y_test) )

# 학습 과정을 그래프로 그려보기

import matplotlib.pyplot as plt

fig, loss_ax = plt.subplots()
acc_ax = loss_ax.twinx()

loss_ax.plot(hist.history['loss'], 'y', label = 'train loss')
loss_ax.plot(hist.history['val_loss'], 'r', label = 'val loss')

acc_ax.plot(hist.history['accuracy'], 'b', label = 'train acc')
acc_ax.plot(hist.history['val_accuracy'], 'g', label = 'val acc')

loss_ax.set_xlabel('Epoch')
loss_ax.set_ylabel('Loss')

acc_ax.set_ylabel('Accuracy')

loss_ax.legend(loc='upper left')
acc_ax.legend(loc='lower left')

plt.show()

# 혼동 행렬(Confusion Matrix)
import numpy as np
from sklearn.metrics import confusion_matrix, classification_report

y_pred = model.predict(X_test)
y_test_p1 = np.argmax(y_test,axis=1) #정답
y_test_p2 = np.argmax(y_pred,axis=1) #예측

print(classification_report(y_test_p1, y_test_p2))
print(confusion_matrix(y_test_p1, y_test_p2))

